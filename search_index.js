var documenterSearchIndex = {"docs":
[{"location":"#ExactPredicates.jl-1","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"This package provides fast and robust predicates for Euclidean geometry, including orient, incircle and insphere.","category":"page"},{"location":"#Robustness-1","page":"ExactPredicates.jl","title":"Robustness","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"Robust means that the code:","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"raises an exception on NaN and Inf arguments;\ngives a correct answer on all other inputs with Float64 coordinates, no matter what (overflow, underflow, etc.);\nin particular, no restriction on the coordinate range.","category":"page"},{"location":"#Why-robustness-matter?-1","page":"ExactPredicates.jl","title":"Why robustness matter?","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"Even if the geometric data is approximate (for example when it comes from measurement), robust computation is important because it guarantees soundness with respect to some combinatorial properties of the predicates. For example orient(a, b, c) == orient(b, c, a) == orient(c, a, b).","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"“Inexact versions of these tests [orient and incircle] are vulnerable to roundoff error, and the wrong answers they produce can cause geometric algorithms to hang, crash, or produce incorrect output.”","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"Jonathan Shewchuk, Robust Adaptive Floating-point Geometric Predicates","category":"page"},{"location":"#Type-for-points-1","page":"ExactPredicates.jl","title":"Type for points","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"The basic type for representing points is NTuple{N, Float64}, where N is 2 or 3. To define the predicates for a type T, simply define a function Tuple(::T) or coord(::T) that output a NTuple{Float64, Float64} that contains the coordinates. Naturally, the computation is only robust if the conversion is robust too. There should be no performance penalty in the conversion.","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"using ExactPredicates\nstruct Point\n    x :: Float64\n    y :: Float64\nend\n\nTuple(p :: Point) = (p.x, p.y)\nincircle(Point(0.0, 0.0), Point(1.0, 0.0), Point(0.0, 1.0), Point(.5, .5))\n\n\ncoord(p :: Float64) = (p, 0.0)\ncoord(p :: Complex) = reim(p)\nincircle(0.0, 1.0, complex(0.0, 1.0), complex(.5, .5))\n\nusing StaticArrays\n# StaticArrays already defines Tuple for SVector\nincircle(SVector(0.0, 0.0), SVector(1.0, 0.0), SVector(0.0, 1.0), SVector(.5, .5))","category":"page"},{"location":"#License-1","page":"ExactPredicates.jl","title":"License","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"The package is released under the MIT license.","category":"page"},{"location":"#Exported-functions-1","page":"ExactPredicates.jl","title":"Exported functions","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"Modules = [ExactPredicates]","category":"page"},{"location":"#ExactPredicates.closestpoint-Tuple{Tuple{Float64,Float64,Float64},Tuple{Float64,Float64,Float64},Tuple{Float64,Float64,Float64}}","page":"ExactPredicates.jl","title":"ExactPredicates.closestpoint","text":"closestpoint(p :: 3, q :: 3, a :: 3) -> Int\n\nReturn 1 if a is closer to p than to q. Return –1 if a is closer to q than to p. Return 0 is a is equaly close to both.\n\n\n\n\n\n","category":"method"},{"location":"#ExactPredicates.closestpoint-Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64},Tuple{Float64,Float64}}","page":"ExactPredicates.jl","title":"ExactPredicates.closestpoint","text":"closestpoint(p :: 2, q :: 2, a :: 2) -> Int\n\nReturn 1 if a is closer to p than to q.\nReturn –1 if a is closer to q than to p.\nReturn 0 is a is equaly close to both.\n\n\n\n\n\n","category":"method"},{"location":"#ExactPredicates.incircle-NTuple{4,Tuple{Float64,Float64}}","page":"ExactPredicates.jl","title":"ExactPredicates.incircle","text":"incircle(a :: 2, b :: 2, c :: 2, p :: 2) -> Int\n\nAssume that a, b and c define a counterclockwise triangle.\n\nReturn 1 if p is strictly inside the circumcircle of this triangle.\nReturn –1 if p is outside.\nReturn 0 if p is on the circle.\n\nIf the triangle is oriented clockwise, the signs are reversed. If a, b and c are collinear, this degenerate to an orientation test.\n\nIf two of the four arguments are equal, return 0.\n\n\n\n\n\n","category":"method"},{"location":"#ExactPredicates.insphere-NTuple{5,Tuple{Float64,Float64,Float64}}","page":"ExactPredicates.jl","title":"ExactPredicates.insphere","text":"insphere(p :: 3, q :: 3, r :: 3, s :: 3, a :: 3)\n\nReturn 1 if a is inside the circumscribed sphere defined by the four points p, q, r and s.\nReturn –1 if a is outside.\nReturn 0 is a lies on the sphere or if the four points are coplanar.\n\n\n\n\n\n","category":"method"},{"location":"#ExactPredicates.orient-NTuple{4,Tuple{Float64,Float64,Float64}}","page":"ExactPredicates.jl","title":"ExactPredicates.orient","text":"orient(p :: 3, q :: 3, r :: 3, a :: 3) -> Int\n\nConsider the oriented plane on which the triangle pqr is positively oriented.\n\nReturn 1 if a is below this plane.\nReturn –1 if a is above this plane.\nReturn 0 if a lies on this plane.\n\n\n\n\n\n","category":"method"},{"location":"#ExactPredicates.orient-Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64},Tuple{Float64,Float64}}","page":"ExactPredicates.jl","title":"ExactPredicates.orient","text":"orient(p :: 2, q :: 2, r :: 2) -> Int\n\nReturn 1 if r is on the left of the oriented line defined by p and q.\nReturn –1 if r is on the right.\nReturn 0 if r is on the line or if p == q.\n\n\n\n\n\n","category":"method"}]
}
